<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/component---src-layouts-index-js-152233edf36abeef3f0f.js" as="script"/><link rel="preload" href="/component---src-templates-post-js-f21795fdd8ddea9ec658.js" as="script"/><link rel="preload" href="/path---fluent-design-system-4bae982b8731110eb15e.js" as="script"/><link rel="preload" href="/app-c6434ca3d0b1ed98141b.js" as="script"/><link rel="preload" href="/commons-5cf4acbe160167cec565.js" as="script"/><title data-react-helmet="true">Lighted Mirror</title><meta data-react-helmet="true" name="description" content="Lighted Mirror &#x27;s site"/><meta data-react-helmet="true" name="keywords" content="blog, Lighted Mirror"/><style id="gatsby-inlined-css"></style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="907178845"><!-- react-empty: 2 --><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0;" data-reactid="3"><div class="blog-post-container" data-reactid="4"><div class="blog-post" data-reactid="5"><h1 style="font-size:40px;font-weight:700;" data-reactid="6">New</h1><p style="color:#6d6d6d;font-size:14px;" data-reactid="7"><!-- react-text: 8 -->November 13, 2017<!-- /react-text --><!-- react-text: 9 --> by <!-- /react-text --><a href="https://github.com/jazzysnail" data-reactid="10">Leon</a></p><p data-reactid="11"><span data-reactid="12">JS</span></p><div class="blog-post-content" data-reactid="13"><p>new 到底是怎么一回事呢？不如一起来实现以下。</p>
<hr>
<h2>Object</h2>
<p>Object 的内部属性使用 [[Prototype]] 来表示对象的原型，在大多数的 js 内核的实现中使用 <code>__proto__</code> 属性，如 chrome。</p>
<h2>Function</h2>
<p>Function 的 实例属性 <code>prototype</code> 的值用于初始化一个新创建对象的的 [[Prototype]] 内部属性，为了这个新创建对象要先将函数对象作为构造器调用。这个属性拥有特性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。</p>
<h2>Constructor</h2>
<p>构造器的 <code>prototype</code> 属性值是一个原型对象，它用来实现继承和共享属性。</p>
<h2>Prototype</h2>
<p>当构造器创建一个对象，为了解决对象的属性引用，该对象会隐式引用构造器的 <code>prototype</code> 属性。通过程序表达式 <code>constructor.prototype</code> 可以引用到构造器的 <code>prototype</code> 属性，并且添加到对象原型里的属性，会通过继承与所有共享此原型的对象共享。另外，可使用 Object.create 内置函数，通过明确指定原型来创建一个新对象。</p>
<h2>New</h2>
<p>产生式 NewExpression : new NewExpression 按照下面的过程执行 :</p>
<ol>
<li>令 ref 为解释执行 NewExpression 的结果 .</li>
<li>令 constructor 为 GetValue(ref).</li>
<li>如果 Type(constructor) is not Object ，抛出一个 TypeError 异常 .</li>
<li>如果 constructor 没有实现 [[Construct]] 内置方法 ，抛出一个 TypeError 异常 .</li>
<li>返回调用 constructor 的 [[Construct]] 内置方法的结果 , 传入按无参数传入参数列表 ( 就是一个空的参数列表 ).</li>
</ol>
<p>产生式 MemberExpression : new MemberExpression Arguments 按照下面的过程执行 :</p>
<ol>
<li>令 ref 为解释执行 MemberExpression 的结果 .</li>
<li>令 constructor 为 GetValue(ref).</li>
<li>令 argList 为解释执行 Arguments 的结果 , 产生一个由参数值构成的内部列表类型 (11.2.4).</li>
<li>如果 Type(constructor) is not Object ，抛出一个 TypeError 异常 .</li>
<li>如果 constructor 没有实现 [[Construct]] 内置方法，抛出一个 TypeError 异常 .</li>
<li>返回以 argList 为参数调用 constructor 的 [[Construct]] 内置方法的结果 .</li>
</ol>
<p><strong>Note:</strong> <code>NewExpression</code> 为对象创建表达式，<code>MemberExpression</code> 为成员表达式，<code>GetValue</code> 为引用规范类型获取具体值的方法，参看 ES 规范 __ 左值表达式__ 部分和 <strong>引用规范类型</strong> 部分。</p>
<p>细心会发现，依据不同的产生式，步骤有一些差别。其实这个差别看起来就像是 <code>new Object</code> 和 <code>new Object(...argList)</code> 的差别，如果 <code>argList</code> 为空应该是无差别的。前面是构造器，其实就构造函数而言还有一种差别是 <code>Date()</code> 和 <code>new Date()</code> 的差别，可以通过在构造器内部使用 <code>instanceof</code> 操作符来进行安全类型检测，不多写。</p>
<p>根据规范原理描述，我们大致可以以下步骤作为简单的实现：</p>
<ol>
<li>创建一个空对象</li>
<li>绑定原型</li>
<li>以 <code>argList</code> 为入参执行构造函数，函数 this 指向新的对象</li>
<li>返回该对象</li>
</ol>
<p>简单书写一下：</p>
<pre><code class="language-js">const _new = function (constructor, ...argList) {
  let _object = new Object()
  _object.__proto__ = constructor.prototype
  constructor.call(_object, ...argList)
  return _object
}
</code></pre>
<pre><code class="language-js">let v = function (val) {
  this.base = val2
}

v.prototype.getValue = function () {
  return this.base
}

// NewExpression : new NewExpression
const _v = _new(v)
// MemberExpression : new MemberExpression Arguments
const _vv = _new(v, 3)

_v instanceof v // => true
_vv instanceof v // => true
</code></pre>
<p>:完</p></div></div></div></div><footer class="footer" data-reactid="14"><p data-reactid="15"><!-- react-text: 16 -->All Content Copyright © <!-- /react-text --><!-- react-text: 17 -->2018<!-- /react-text --><!-- react-text: 18 -->-2018 <!-- /react-text --><a href="/blog/about-us" data-reactid="19">Lighted mirror</a></p><p data-reactid="20"><!-- react-text: 21 -->Powered by <!-- /react-text --><a href="https://www.gatsbyjs.org/" target="_blank" data-reactid="22">Gatsby</a></p></footer></div></div><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-c6434ca3d0b1ed98141b.js","195351340454287":"component---src-templates-post-js-f21795fdd8ddea9ec658.js","162898551421021":"component---src-pages-404-js-4503918ea3a16cfcdb75.js","169928946856436":"component---src-pages-about-us-js-597e94bd0aac6e00cf64.js","35783957827783":"component---src-pages-index-js-6ac6ca4987a5428a931a.js","60335399758886":"path----399b7141816ef9ae6952.js","207392420243428":"path---es-reference-4bae982b8731110eb15e.js","45924910676260":"path---es-new-4bae982b8731110eb15e.js","46606309235019":"path---fluent-design-system-4bae982b8731110eb15e.js","66207594746836":"path---daily-prototype-005-4bae982b8731110eb15e.js","44538366908094":"path---daily-prototype-004-4bae982b8731110eb15e.js","144119754503181":"path---daily-prototype-003-4bae982b8731110eb15e.js","9716589766898":"path---daily-prototype-002-4bae982b8731110eb15e.js","223072412541078":"path---daily-prototype-001-4bae982b8731110eb15e.js","92406996478101":"path---disconf-4bae982b8731110eb15e.js","215314043785064":"path---pure-function-4bae982b8731110eb15e.js","89450997894629":"path---test-4bae982b8731110eb15e.js","40214885644169":"path---jazzysnail-font-4bae982b8731110eb15e.js","147175524700069":"path---not-defined-undefined-4bae982b8731110eb15e.js","1708766880004":"path---course-play-vue-logo-4bae982b8731110eb15e.js","137463965619010":"path---npm-rimraf-4bae982b8731110eb15e.js","188964688802783":"path---my-understanding-on-closures-4bae982b8731110eb15e.js","254022195166212":"path---404-a0e39f21c11f6a62c5ab.js","120678318354":"path---about-us-a0e39f21c11f6a62c5ab.js","142629428675168":"path---index-52ff870f0e032ab10f85.js","178698757827068":"path---404-html-a0e39f21c11f6a62c5ab.js","114276838955818":"component---src-layouts-index-js-152233edf36abeef3f0f.js"}/*]]>*/</script><script>/*<![CDATA[*/!function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",["/commons-5cf4acbe160167cec565.js","/app-c6434ca3d0b1ed98141b.js","/path---fluent-design-system-4bae982b8731110eb15e.js","/component---src-templates-post-js-f21795fdd8ddea9ec658.js","/component---src-layouts-index-js-152233edf36abeef3f0f.js"])/*]]>*/</script></body></html>